\section{计算形式幂级数的牛顿迭代法的常数优化}
该内容基于negiizhao的博客\footnote{
    \sout{noip退役选手的一些扯淡}关于优化形式幂级数计算的牛顿法的常数\\
    \url{http://negiizhao.blog.uoj.ac/blog/4671}
}。

记长度为$2n$的DFT/IDFT的计算时间为$T(n)$，$n$次形式幂级数乘法的时间为$(3+o(1))T(n)$，
下面算法的运行时间均以$T(n)$为基准衡量。运行时间有理论上证明与实际测试结果支持。测试用
模数为998244353，测试规模为$2^{22}$，每个算法重复运行100次。以下时间复杂度证明假装
$T(n)=2T(n/2)$，即不考虑lg的增长。

\subsection{卷积}
牛顿迭代法需要遇到不同规模的卷积，原先的卷积实现使用动态计算位逆序和利用消去引理定位对应的
单位根。既然我们已经知道了卷积的最大规模，可以使用最大规模2倍的空间预处理出每种规模的单位根
和位逆序数组。这样在访问单位根时对缓存友好。实验表明此法的速度是原先的2倍，且代码几乎不需要
改动（仅修改init与NTT部分，封装的魅力！！！）。由于本节主要注重牛顿迭代法本身的优化，下面
的算法无论是否优化，都使用优化后的NTT作为基础设施。
\subsection{求逆}
\subsubsection{原算法}
原算法在每次迭代中执行2次DFT，1次IDFT，长度均为$2n$级别。记规模为$n$的多项式求逆时间复杂度
为$A(n)$，有$A(n)=A(n/2)+(3+o(1))T(n)$，解得$A(n)=(6+o(1))T(n)$。事实上，从模$x^n$
推到$x^{2n}$的过程的复杂度等于求模$x^n$意义的复杂度。
\subsubsection{优化}

\subsection{除法}
\subsection{平方根}
\subsection{对数}
\subsection{指数}
\subsection{实验结果}

\begin{tabular}{c|c}
\hline
算法 & 测试比值（优化前/优化后，以$T(n)$为基准）\\
\hline
多项式乘法 & -/-\\
多项式求逆&-/-\\
多项式除法&-/-\\
多项式平方根&-/-\\
多项式对数&-/-\\
多项式指数&-/-\\
\hline
\end{tabular}
