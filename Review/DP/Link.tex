\section{基于连通性状态压缩的动态规划/轮廓线DP/插头DP}
\subsection{简单回路问题}
例题：ural 1519

给定一个棋盘，某些格子不能经过，其余格子必须经过，求有多少条简单回路。
\subsubsection{最小表示法}
最小表示法用于表示行内格子的连通性。有两种方法：
\begin{itemize}
    \item 有障碍的格子标记为0，连通的格子标记为同一个数，并且$i$比$i+1$更早出现。
    预处理连通状态时使用DFS计算，同构于集合划分问题，状态总量为贝尔数。
    \item 有障碍的格子标记为0，其余格子标记为与其连通的最左格子的列号。
\end{itemize}

下文均使用第一种方法。存储时将其编码为$k$进制数，$k\geq$连通块个数+1。为了提高运算效率，
将$k$对齐至2的幂。
\subsubsection{状态的表示}
在例题中，每个格子与4个相邻格子都有可能连通，连接的部分称为``插头''。由于转移是
逐行进行的，下一行的插头受到上一行下插头的影响，因此每行需要用二进制表示当前行对应位置
是否有下插头。由于最后需要围成一个回路，还要维护行内格子之间的连通性。因此使用$F(i,j,k)$
表示前$i$行，下插头状态为$j$，连通性为$k$的方案数。注意到若该格子没有下插头，则它的连通性
不影响下一行的插头。那么干脆直接记录下插头的连通性，若不存在下插头则标记为0。

鉴于逐格递推比逐行递推更有优势，这里仅记录逐格递推。

用状态$F(i,j,k)$表示当前处理到第$i$行，已经处理完前$i-1$行和第$i$行前$j$列的格子，插头
连通性为$k$的方案数。已决策的格子与未决策格子之间的分界线称为``轮廓线''。在转移的过程中，
除了$n$个下插头外，第$i$格到第$i+1$格还有一个右插头。$k$从左到右表示$n+1$个插头的连通性。

考虑$k$需要使用的进制，由于一个回路最多有$m/2$个连通块，在例题中至少要用7进制，使用8进制
更加快速。
\subsubsection{状态的转移}
\paragraph{一般转移}
逐格递推，可以发现每移动一格最多有2个插头被改动。

枚举当前格子的插头，状态共有3种转移：

下文的``相接位置''指代轮廓线与当前格子的两条邻接边，``对应位''指转移前相接位置的位与
转移后新边的位。
\begin{itemize}
    \item 新建连通分量：相接位置没有右插头和下插头，当前格子有右插头和下插头，将对应位置
    置为新的标号，然后重新$O(n)$扫描以保持最小表示法。
    \item 合并连通分量：当前格子有左插头和上插头。若对应的右插头和下插头未连通，则将含有
    这两个标号的所有位置标记为同一标号，并重新扫描，再将对应位置0。若其已连通，则只允许在
    最后一个非障碍格子中合并为一条回路。
    \item 保持连通分量：相接位置有右插头或下插头恰好一个，当前格子有上或左
    插头恰好一个，有下或右插头恰好一个。不需要重新扫描，可以$O(1)$转移。
\end{itemize}
\paragraph{障碍格子处理}
当遇到障碍格子时，相接位置必须没有插头，由于该格子不能铺线，对应位置上没有插头，仍然置为0，
所以状态不变。
\paragraph{跨行处理}
当从上一行的最后一个格子转移到下一行的第一个格子时，不能从有右插头的状态转移。实现时
保证上一行的最后一个格子不能产生右插头，转移到首格时移位处理。
\paragraph{始末状态}
初始状态和终止状态都没有插头，值为0。
\paragraph{小结}
在推导状态转移时需要注意以下方面：
\begin{itemize}
    \item 状态表示是否存储足够的信息
    \item 连通分量的三种变化情况
    \item 移动格子时要保证所有裸露的插头都在轮廓线上
    \item 转移的目标状态表示的是{\bfseries 轮廓线上插头}的连通性。
    \item 转移完状态后是否需要重新扫描以保持最小表示法的性质
    \item 障碍格子和行首尾格子的处理
    \item 始末状态
    \item 从可行性与最优性对无效状态进行剪枝
\end{itemize}
\subsubsection{程序的实现与优化}
直接枚举状态会产生大量的无效状态，因此使用队列从初始状态开始转移。枚举每个格子，
枚举循环队列中的状态，计算出可以转移的目标状态。使用Hash表存储当前已经转移过的状态的
dp值，Hash表的size不必太大，每转移一个格子开一个新的Hash表。

参考代码：
\lstinputlisting{Source/Templates/Link.cpp}
\subsubsection{简单回路问题与括号表示法}
事实上对于简单回路问题，裸露的插头必须在轮廓线上，轮廓线上的插头必定两两匹配。
又因为求的是简单回路，匹配的插头不会交叉。那么可以使用一个括号序列来表示连通性，
0表示没有插头，1表示左端，2表示右端，使用4进制表示状态。

再次根据连通分量的变化讨论转移：
\begin{itemize}
    \item 新建连通分量：要求相接位置没有插头，转移时将对应位分别置为1和2。
    \item 合并连通分量：需要按照相接位置的插头是左括号还是右括号讨论，记
    右插头为$A$，下插头为$B$：
    \begin{itemize}
        \item $A$左$B$左：将$B$对应的右括号修改为左括号
        \item $A$左$B$右：此时将连成一条回路，当其为最后一个无障碍格子时才转移
        \item $A$右$B$左：不需要额外修改
        \item $A$右$B$右：将$A$对应的左括号修改为右括号
    \end{itemize}
    最后将对应位都置为0。
    \item 保持连通分量：直接继承有插头位置的左右标号
\end{itemize}

此法思维难度低，实现简单，程序速度快。但是括号表示法的局限性较大，参见下文的广义表示法。

参考代码：
\lstinputlisting{Source/Source/Link/5056.cpp}
\subsubsection{非回路问题转化为简单回路问题}
求从棋盘中一个特殊点经过所有非障碍点走到另一个特殊点的方案数。

可以尝试额外构造一条宽度为1的路径使其连通，新棋盘的一条回路对应了原棋盘的一条路径。
\subsection{简单路径问题}
给定一个棋盘，某些格子不能经过，其余格子必须经过，求有多少条简单路径。

此时非轮廓线上有不超过2个裸露插头。若使用最小表示法，则还要记录每个插头与路径端点的连通情况。
若使用括号表示法，则再引入标号3指示独立插头，说明这个插头连接着路径的一端，转移时需要保证任意
时刻轮廓线上的独立插头不超过2个。
\subsection{最大化回路/路径/连通块点权和}
\begin{itemize}
    \item 回路：注意仅在连为回路的情况更新答案。由于允许有些格子不经过，会导致回路外还可能
    存在一些孤立的路径，需要特判连为回路后轮廓线上是否均没有插头。
    \item 路径：额外使用2bit记录轮廓线上方（不含边界）裸露插头的个数，同时引入独立插头标记。
    注意最后连为一条路径时要保证轮廓线上插头+裸露插头的个数$\leq 2$。
    \item 连通块：仅记录$m$个格子的连通性。特别考虑移动轮廓线后消失的格子（即当前格子的上方）
    ，若它被选中且当前格子不选，需要保证它至少与轮廓线上的其它格子连通。
\end{itemize}
\subsection{广义括号表示法}
括号表示法的局限性在于其只能表示在轮廓线上最多有2个插头的连通分量。

将最左插头标记为``(''，最右插头标记为``)''，中间的插头标记为``)(''，独立插头标记为``()''，
能够匹配的括号对应的插头是连通的。
\subsection{棋盘染色问题}
棋盘上格子的连通性取决于棋盘格子的颜色，因此需要额外记录轮廓线上棋盘格子的颜色。
\subsection{局部连通性加速DP}
有些题目会给出一个特殊的构图方法，其连边具有局部性质。那么就可以讨论局部连通性计算转移矩阵，
使用矩阵快速幂加速DP。

上述内容参考了IOI2018国家集训队论文集中陈丹琦的《基于连通性状态压缩的动态规划问题》。
