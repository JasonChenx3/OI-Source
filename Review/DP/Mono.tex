\section{决策单调性DP}
斜率优化与四边形不等式是决策单调性DP的特殊情形，参见第~\ref{Slope}节与
第~\ref{Quad}节。

在分析、实现、Debug难度、错误率方面，分治DP<决策二分栈DP<斜率优化DP。在题目条件与
运行时间允许的情况下，优先使用分治DP。
\subsection{双指针优化}
对于dp方程为$f_i=max/min\{w_{j,i}\}$的问题，记$f_i$的转移决策点为$P_i$，
若对于任意$i<j$，满足$P_i<P_j$，且对于任意$i$的可行转移点集合$P$，有
$P_i=P_{min}$，那么可以维护2个指针，一个指示$i$，一个指示转移决策点，
当不在可行转移点集合时才移动决策点，时间复杂度$O(n)$。
\subsection{决策二分栈DP}\label{BSDP}
该方法适用于dp方程为$f_i=max/min\{g_j+w_{j,i}\}$，其中$g_j$是一些与$j$有关的函数，
可能包含$f_j$，且对于任意$i<j$，满足$P_i<P_j$，$w_{j,i}$可以快速算出。

由于这类题无法贪心，必须存储决策转移点。不过注意到$i$对应的决策转移点随着$i$的递增而递增，
反过来每个决策转移点映射了一段$i$的区间。那么可以维护一个单调栈/队列，内部元素均为当前
有效决策转移点（还未计算转移的位置落在它们的管辖区间内）。转移点之间维护一个分界点，使用二分
计算（若函数较简单也可以直接求交点，还可以用牛顿迭代法）。添加新转移点时计算新点与栈顶/队尾的
转移点的分界点，若产生交叉则将其弹出。计算转移决策点时也使用二分计算。时间复杂度$O(n\lg n)$。

在二分决策点$x<y$的分界点时，左端点可设为$y$而不是1，因为$f_i$只可能从$j\leq i$的位置
转移。{\bfseries 注意对于连续决策函数，即使其DP值需要取整，二分分界点时也要使用浮点计算。}

\paragraph{例题} [NOI2009]诗人小G

参考代码：
\lstinputlisting{Source/Source/DP/1912.cpp}

上述内容参考了FlashHu的博客\footnote{
    DP的各种优化（动态规划，决策单调性，斜率优化，带权二分，单调栈，单调队列）\\
    \url{https://www.cnblogs.com/flashhu/p/9480669.html}
}。
\subsection{分治DP}
该方法适用于$f_i$之间独立且决策二分栈DP中$w_{j,i}$无法快速计算或不好写的情况。

例题：「雅礼集训 2017 Day5」珠宝

这是一个经典的背包问题，但是按照背包做会TLE。发现代价$c$很小，考虑按照$c$分类
然后转移，花费$kc$的代价时贪心地选取价值前$k$大的物品（我的思路止步于此）。

由于同一条dp依赖链上的位置模$c$同余，可以考虑再按照位置模$c$分类，将每一条链拆开处理。
注意到选取前$k$大物品的代价的增长率是单调非增的，尝试验证该dp是否有决策单调性。

采用反证法，设两个同类dp点$i,j$，满足$i<j$，记它们的转移决策点分别为$P_i,P_j$，
满足$P_i>P_j$。记原先的dp数组为$dp$，前$k$大前缀和数组为$w$。根据决策点的定义，有：
\begin{eqnarray*}
    dp[P_i]+w[i-P_i]>dp[P_j]+W[i-P_j]\\
    \Rightarrow dp[P_i]-dp[P_j]>W[i-P_j]-w[i-P_i]\\
    dp[P_i]+w[j-P_i]\leq dp[P_j]+W[j-P_j]\\
    \Rightarrow dp[P_i]-dp[P_j]\leq W[j-P_j]-w[j-P_i]\\
\end{eqnarray*}

由不等式传递性可得$W[i-P_j]-w[i-P_i]<W[j-P_j]-w[j-P_i]$，由于$i<j$且增长率单调非增，
与该式产生矛盾，因此转移点是单调的。

那么可以写一个分治程序$solve(l,r,L,R)$，表示处理$[l,r]$之间的dp值，转移区间在$L,R$。
每次在转移区间内扫一遍求出$mid$的dp值，得到转移点，最后左右递归处理，时间复杂度$O(ck\lg k)$。

代码：
\lstinputlisting{Source/Source/DP/LOJ6039.cpp}

上述内容参考了ShichengXiao的博客\footnote{
    DP及其优化\\
    \url{https://www.cnblogs.com/ShichengXiao/p/9501386.html}
}。

注意$w_{j,i}$无法快速算出但是可以快速转移（类似莫队）时，要预处理一部分区间以保证
分治复杂度。{\bfseries 准确地说，分治复杂度要严格与决策区间长度+处理区间长度相关。}

例题：CF868F Yet Another Minimization Problem

推出DP方程，滚动第一维，发现转移具有决策单调性，并且无法快速计算$w_{j,i}$，考虑使用分治
解决。记$solve(l,r,b,e)$表示计算$[l,r]$的dp值，决策区间在$[b,e]$，记$m=(l+r)/2$。
原做法：记$end=min(e,m)$，暴力加入$(end,m]$内的元素，然后从$end$到$n$边计算dp边添加
新元素。复杂度不保的地方在于每次都暴力加入$(end,m]$内的元素。

正确姿势：注意到$b<l$，向左递归时都要用到区间$[b,l)$，考虑每次调用$solve$前都已加入
$[b,l)$的元素。接下来分析3个子过程，记单层分治复杂度中与处理区间长度相关的项为$A$，
与决策区间长度相关的项为$B$：

\begin{itemize}
    \item 寻找$m$的决策点$p$：该过程需要用到区间$[b,m]$，首先再加入$[l,m]$的元素，
    然后从$b$开始移动向$end$缩减区间计算dp，最后还原区间$[b,end]$，删除$[l,m]$。
    时间复杂度$A+B+B+A$。
    \item 准备左递归要预处理的区间：预处理部分已就绪，直接递归。
    \item 准备右递归要预处理的区间：需要将区间$[b,l)$迁移至区间$[p,m)$，这个过程
    可视为左端点和右端点的移动，因此复杂度仍然是靠谱的。最后仍然要退回$[b,l)$给调用端
    用，时间复杂度$B+A+A+B$。
\end{itemize}

参考代码：
\lstinputlisting{Source/Source/DP/CF868F.cpp}

该内容参考了FlashHu的题解\footnote{
    洛谷CF868F Yet Another Minimization Problem（动态规划，决策单调性，分治）\\
    \url{https://www.cnblogs.com/flashhu/p/9495839.html}
}。

{\bfseries 小心地控制复写顺序连滚动数组都不用（右-中-左）。}

\subsection{时间复杂度陷阱}
如遇到多轮相同的分治DP，则考虑将时间复杂度优化到与轮数无关。
否则容易被卡常/TLE。

例题：[Apio2014]序列分割（2019.4.8：调了一下午终于在bzoj上变成的rank1）

得出得分与序列切分顺序无关后就可以开始分治DP了。进一步考虑答案的实际表达式，
记$b_i$为第$i$块的总和，有$ans=\frac{1}{2}\left(\left(\sum{b_i}\right)^2-min\sum{b_i^2}\right)$。
原问题被转化为最小化块的平方和，但是仍然无法降低时间复杂度，若去掉因子$k$则无法保证其块数恰好为$k$。

不过即使数组存在负数我们也可以求出块平方和的最小值，以及对应的最小的块数，使用斜率优化解决，然后
再套WQS二分。

综上所述，当遇到多轮分治DP时考虑转化为WQS二分。
\subsection{决策单调性快速判断}
该内容参考了FlashHu的博客\footnote{
    不失一般性和快捷性地判定决策单调（洛谷P1912 [NOI2009]诗人小G）（动态规划，决策单调性，单调队列）\\
    \url{https://www.cnblogs.com/flashhu/p/9521094.html}
}。

定义决策函数$F_j(i)$为从$j$转移到$i$的dp值。

具有决策单调性的DP有以下特征：

\begin{itemize}
    \item 决策函数是直线（使用斜率优化）。
    \item 发现某些部分分决策函数是直线，可以使用斜率优化做。部分分有一定的提示作用。
    \item 两个决策函数只有一个交点。
    \item 决策函数的导函数单调：
    \begin{itemize}
        \item 导函数单调递增，求最大值/单调递减，求最小值：单调栈
        \item 导函数单调递增，求最小值/单调递减，求最大值：单调队列
    \end{itemize}
    \item 决策函数可表示为多个满足决策单调性的子决策函数之和。
    \item 输出决策点发现决策具有单调性。
    \item 带绝对值的决策函数拆成两种情况后均具有单调性。遇到关于下标之差绝对值的决策函数，
    拆成两次DP来做，每次强制单方向转移。
\end{itemize}
