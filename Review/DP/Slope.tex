\section{斜率优化}\label{Slope}
\subsection{推导}
当状态转移方程为如下形式时：
\begin{displaymath}
    dp[i]=min(a[i]*b[j]+c[i]+d[j])
\end{displaymath}
考虑使用斜率优化。

以下推导假设$a[i]$单调递减且$b[j]$单调递增：

设决策点$j<k<i$，且从点$k$转移到$i$不差于从点$j$转移到$i$，
易证从点$k$转移到$i+1$同样不差于从点$j$转移到$i+1$。称该性质为决策单调性。

接下来考虑点$k$不比点$j$更差的条件：
\begin{eqnarray*}
    a[i]*b[j]+c[i]+d[j]&\geq&a[i]*b[k]+c[i]+d[k]\\
    \Rightarrow -a[i]&\geq&\frac{d[k]-d[j]}{b[k]-b[j]}
\end{eqnarray*}

记斜率
\begin{displaymath}
    slope(i,j)=\frac{d[j]-d[i]}{b[j]-b[i]}
\end{displaymath}

斜率可以使用单调队列维护，记$q[b]$为队首，$q[e-1]$为队尾：
\begin{itemize}
    \item 若$-a[i]\geq slope(q[b],q[b+1])$，则表明$q[b+1]$不比$q[b]$更差，
    弹出$q[b]$。
    \item 若$slope(q[e-2],q[e-1])\geq slope(q[e-1],i)$，则说明若
    $q[e-2]$被弹出，$q[e-1]$一定被弹出，所以$q[e-1]$无效，可以先弹出。
\end{itemize}

从``形''的角度理解，单调队列维护了一个下凸壳。
\subsection{应用}
主要过程就是研究决策单调性满足的条件，然后选取适当的数据结构维护信息，快速dp。

实际应用中需注意以下几点：
\begin{itemize}
    \item 比较斜率时尽量使用乘法避免精度误差，提高效率，要考虑变号时的符号问题，最好
    保持分母为正。\CJKsout{（反正也就两处符号，面向样例编程就行了）}。
    \item 若$a[i]$单调，使用单调队列，否则使用~\ref{BSDP}所述的决策二分栈/队列。
    \item 若$b[i]$单调，使用单调队列，否则使用平衡树维护凸壳/CDQ分治（留坑待补）/李超线段树。

    {\bfseries 血泪史：「CEOI2017」Building Bridges

    事实上动态凸壳的维护不是很好处理，因为浮点数的精度问题不好解决。我调了3个多小时还是
    WA（更悲惨的是总共只WA一半，但每组捆绑测试都有测试点WA）。可以考虑维护动态半平面交，
    毕竟HPI还是比较成熟的，由于半平面只有插入，使用第~\ref{BinIns}节所述的二进制分组
    解决。事实证明HPI+二进制分组法数值稳定性比较好（一遍AC，速度比动态凸包快，代码比动态
    凸包短）。
    }
\end{itemize}

以上内容参考了MashiroSky的博客\footnote{斜率优化学习笔记 - MashiroSky
    \url{https://www.cnblogs.com/MashiroSky/p/6009685.html}
}。
\subsection{树上斜率优化}
例题：NOI2014 购票

我原先的做法：维护每条重链的完整单调队列，查询时二分出单调队列的一段，然后二分
转移点。最后讨论该段前后不在队列上的点取出暴力转移。虽然最终得到满分，但是这种
做法严重依赖于数据强度，容易被Hack，并且细节很多。\CJKsout{2019.3.17：为什么
又是rank2。。。}
\subsubsection{点分治}
考虑树退化成链的情况，由于转移长度有限制且不单调，无法使用单调队列维护。使用CDQ分治解决：
\begin{enumerate}
    \item 递归处理$[l,m]$
    \item 计算$[l,m]$到$[m+1,r]$的转移：
    \begin{enumerate}
        \item 将$[m+1,r]$按照更新左边界点降序排序，忽略左边界点超过$m$的点
        \item 将$[l,m]$从右到左加入，维护凸包，加入点$i$后，二分转移所有左边界点
        恰好为$i$的点
    \end{enumerate}
    \item 递归处理$[m+1,r]$
\end{enumerate}

现在考虑树的情况，树上分治一般使用点分治：

记当前分治过程的重心为$g$，连通块的根为$u$，节点$u$的还未尝试转移的深度最浅的祖先$top_u$：
\begin{enumerate}
    \item 由于这是有根树，$u$所在的子连通块与其它连通块并不平等，
    且$g$需要从$u$处转移，因此首先递归计算$u$的子连通块。
    \item 若$u\neq g$，此时$g$的所有祖先都已经计算完毕，尝试从$u$到$g$的父亲转移$g$。
    \item DFS遍历子连通块的节点，序列化点的编号，记录所属连通块的根$bel$。
    \item 将节点按照$top$排序，从$u$到$u$的祖先逐个加入凸包，尝试更新dp值，
    同时更新$top=bel$。
    \item 递归分治子连通块。
\end{enumerate}

时间复杂度$O(n\lg^2 n)$。
\subsubsection{可持久化单调队列}
对于可以使用单调队列解决的树上斜率优化问题，在插入一个点时在该点存储被该点
弹出的节点编号，回溯时删除自身，同时恢复被弹出的节点。由于不能确定每个点被
弹出和恢复的次数，无法保证这个方法的复杂度。

可以发现在加入一个决策点后，队列只要覆盖一个决策点。只需在修改前记录被覆盖位置的决策点和
原队列的长度，回溯时恢复该位置与队列长度。插入时使用二分快速计算覆盖位置。不执行队列的弹出
操作，同样使用二分计算转移点（这样也可以应对自变量$x$不单调的情况）。

对于本题，由于还有$l$的限制，如果只维护单个凸包，最优决策点有可能被删去
\CJKsout{（我的做法就是暴力处理这种情况）}。由于凸包是可并的，可以像线段树那样维护深度
区间凸包。查询时每个连续区间都二分找到最优决策点，合并时选取这些决策点的最优解，单次查询
时间复杂度$O(\lg^2 n)$。修改时按照上文所述修改$O(\lg n)$个区间，单次修改时间复杂度
$O(\lg^2 n)$。

该内容参考了xyz32768\footnote{
    [BZOJ3672][Noi2014]购票（斜率优化+点分治）\\
    \url{https://blog.csdn.net/xyz32768/article/details/82709944}
}
和Sakits\footnote{
    bzoj3672: [Noi2014]购票（树形DP+斜率优化+可持久化凸包）\\
    \url{https://www.cnblogs.com/Sakits/p/8215297.html}
}的博客。
\subsection{CDQ分治维护凸包}
例题：NOI2007 货币兑换

记第$i$天最大收益为$c_i$，将其兑换为AB券的数量为$(a_i,b_i)$。那么$j$买入到$i$卖出的
转移就相当于计算$A_ia_j+B_ib_j$的最大值。

有两种分析方法：
\begin{itemize}
    \item 设$a_j<a_k$，在转移点$i$时，点$j$比点$k$优蕴含着
    $(a_j-a_k)A_i+(b_j-b_k)B_i>0$，化简为
    $\frac{b_j-b_k}{a_j-a_k}<-\frac{A_i}{B_i}$。将$(a,b)$视作点，
    同上文的分析，这里维护$i$之前所有转移点$(a,b)$的上凸包，二分寻找两边斜率包含
    $-\frac{A_i}{B_i}$的点作为决策点。
    \item 将$A_ia_j+B_ib_j$视作点$(a_j,b_j)$到直线$A_ix+B_iy=0$的距离*常数，
    那么最远点可以使用这条直线的平行线夹逼得到。
\end{itemize}

上述分析是等价的，由于$a_i$不单调，需要维护动态凸包（这里的$a_i$不是预先知道的，不能用李超树）。
考虑使用CDQ分治，即每次递归处理完左边的答案后，使用左边的凸包转移右边的点。递归前预排序斜率，
在递归时分发到左右区间，这样就保证右边点的斜率是有序的，可以$O(区间长度)$扫描转移。至于凸包，
可以在回溯时归并排序保证水平序。

上述内容参考了2008年陈丹琦的集训队作业《从〈Cash〉谈一类分治算法的应用》。
