\section{二分图}
\index{B!Bipartite Graph}
\subsection{二分图判定}
\begin{property}
	二分图中不存在奇环。
\end{property}
如果存在奇环，则必有一条边的端点属于同一集合。
所以可以使用DFS染色来判定二分图，遇到矛盾则退出。

\lstinputlisting[title=BGJudge.cpp]{NetworkFlows/BGJudge.cpp}

\subsection{二分图最大匹配}

\subsubsection{匈牙利算法}
\index{H!Hungarian Algorithm}

匈牙利算法的主要步骤就是遍历左集合的每一个顶点，使得其尽可能找到一个匹配。
要为该顶点找到一个匹配，首先遍历边，如果右顶点已经有匹配，则递归尝试让该
匹配点重新找一个匹配，如果右顶点无匹配或者更换匹配成功，则这条边是一个匹配。

原则：有机会上，没机会创造机会也要上。
\footnote{Dark\_Scope 趣写算法系列之--匈牙利算法
	\url{https://blog.csdn.net/dark\_scope/article/details/8880547}}

感性的算法的正确性证明：每次递归时匹配数只增不减，且递归有权修改整个连通块
的着色情况。（似乎并没有什么说服力）。

\index{*TODO!匈牙利算法标准描述与正确性证明}

\subsubsection{Hopcroft–Karp Algorithm}
\index{H!Hopcroft–Karp Algorithm}
暂时先坑着\sout{为什么不写Dinic呢}。
\index{*TODO!Hopcroft–Karp算法}

\subsubsection{例题}

Luogu P1129 [ZJOI2007]矩阵游戏
\footnote{\url{https://www.luogu.org/problemnew/show/P1129}}

首先用二分图最大匹配找到n个不同行且不同列的黑格子（置换矩阵P），然后就可以操作得到
目标矩阵（单位矩阵I）了。

\lstinputlisting[title=Luogu P1129]{Source/Unclassified/Done/1129.cpp}

\subsection{二分图最大权匹配 Kuhn-Munkras Algorithm}
\index{K!Kuhn-Munkras Algorithm}
\sout{先用费用流做吧，暂时先坑着。}
\subsubsection{起步}
维护每个左/右顶点的权值（称为顶标），所有节点的顶标和为答案上界。
令每个左顶点的顶标为出边边权最大值，右顶点顶标为0。

对每个顶点运行匈牙利算法，若左右顶点顶标之和等于边权，则考虑连边；
若无法为当前点找到匹配，则将访问到的左顶点顶标-1，右顶点顶标+1，
等价于使答案上界-1（DFS访问树中的叶子必为左顶点），重新为该点寻找匹配。
把任意二分图当做完全二分图（不存在的边权值为0），迭代必定会结束。

这种做法能够保证在找到最大匹配的情况下使权值和最大。
\subsubsection{优化1}
可以发现在左-1右+1后，原先等于左右顶点顶标之和的边仍然被经过，
一个简单的思路是一次性突破``瓶颈''，即令下次增广时终点位置处的某条边从
不可连边变为可连边，每次DFS增广时维护（顶标和-边权）的最小值$d$，
若匹配失败则左$-d$右$+d$。

这才是复杂度比较靠谱的算法（$O(n^3)$）。
\subsubsection{优化2}
在匹配每个点时，初始化所有右顶点的松弛函数$slack$为$\infty$，然后
DFS时$slack$维护（顶标和-边权）的最小值。若匹配失败则令$d$为未访问右
顶点的$slack$函数最小值，左$-d$右$+d$，同时未访问节点的$slack-=d$。

该优化的复杂度似乎没变，但实测该方法比优化1的效率更高（3x）。
\subsubsection{优化3}
考虑记录其增广时的路径，然后将递归算法转换为非递归算法。
\begin{lstlisting}
int w[size][size],lh[size],rh[size],pair[size],
    pre[size],slack[size];
bool flag[size];
void aug(int s) {
    reset(flag);
    reset(pre);
    reset(slack,0x3f);
    pair[0]=s;
    int u=0;
    do {
        int v=pair[u],minh=inf,nxt;
        flag[u]=true;
        // `再次DFS后新访问到了点u和它的匹配点`
        // `为点v找新匹配点`
        for(int i=1;i<=n;++i)
            if(!flag[i]){
                int delta=lh[v]+rh[i]-w[v][i];
                if(delta<slack[i])
                    slack[i]=delta,pre[i]=u;
                    // `点i的匹配点有可能置换为u的匹配点，`
                    // `以腾出u的匹配点的空位`
                if(minh>slack[i])
                    minh=slack[i],nxt=i;// `点i下次将被访问`
            }
        //松弛
        for(int i=0;i<=n;++i)
            if(flag[i])lh[pair[i]]-=minh,rh[i]+=minh;
            else slack[i]-=minh;
        u=nxt;
    } while(pair[u]);// `直到找到未匹配点为止`
    // `置换匹配`
    while(u) {
        int p=pre[u];
        pair[u]=pair[p];
        u=p;
    }
}
int KM(int n) {
    for(int i=1;i<=n;++i) {
        int maxh=0;
        for(int j=1;j<=n;++j)
            maxh=std::max(maxh,w[i][j]);
        lh[i]=maxh;
    }
    reset(rh);
    reset(pair);
    for(int i=1;i<=n;++i)
        aug(i);
    int res=0;
    for(int i=1;i<=n;++i)
        res+=w[pair[i]][i];
    return res;
}
\end{lstlisting}
实测该方法比优化2的效率更高（2x）。
\index{*TODO!解释KM算法优化的合理性}
\subsection{二分图常见模型}
\subsubsection{最小点覆盖}
\index{K!König's theorem}
\begin{theorem}[König's Theorem]
	最小点覆盖数=最大匹配数。
\end{theorem}

使用反证法证明：如果有一条边两端顶点都不在最大匹配上，那么这条边可以进入最大匹配
成为一个更大的匹配边集，所以与最大匹配的假设矛盾。

\subsubsection{最大独立集}

设最大独立集为$U$,顶点集合为$V$，最大匹配边集为$M$

\begin{theorem}
	$|U|=|V|-|M|$
\end{theorem}

证明：

\begin{enumerate}
	\item \begin{lemma}
		      $|U|\leq |V|-|M|$
          \end{lemma}
          因为每个匹配中有一个点不在集合$U$中，所以$|U|\leq |V|-|M|$。
	\item \begin{lemma}
		      $|U|\geq |V|-|M|$
          \end{lemma}
          首先点集去掉最大匹配覆盖的点集后为独立集，即$|U|\geq |V|-2*|M|$。
          若存在边$(u,v)\in M$,且存在边$(u,a),(v,b)$,点$a$和点$b$都不被
          覆盖,则：
          \begin{itemize}
              \item 若存在$(a,b)$，则有加入边$(a,b)$后有更大的匹配；
              \item 若不存在$(a,b)$,则使用边$(u,a),(v,b)$代替$(u,v)$后
              有更大的匹配。
          \end{itemize}
          因此从最大匹配的每个匹配中选择同一边的点放入独立集中将不会与其他节点相连
          （匹配中的点不相连且不与匹配外的点相连）。
          所以$|U|\geq |V|-2*|M|+|M|=|V|-|M|$。
\end{enumerate}

综上所述$|U|=|V|-|M|$。

\subsubsection{DAG最小路径覆盖}

\paragraph{最小不相交路径覆盖}

将顶点拆成左右两点，若存在边$u->v$则连边$Lu->Rv$,求二分图最大匹配。

\begin{theorem}
	最小路径覆盖数=顶点数-二分图最大匹配数。
\end{theorem}

证明：二分图中每增加一个匹配，就意味着减少一条路径。

\paragraph{最小可相交路径覆盖}

先用Floyd求出传递闭包，转化为最小不相交路径覆盖问题。

证明：如果要从a走到b，直接连边即可，这样就可以避开中间点的限制。

以上内容参考了罗茜\footnote{二分图详解及总结
	\url{https://www.cnblogs.com/alihenaixiao/p/4695298.html}},
justPassBy\footnote{有向无环图（DAG）的最小路径覆盖
	\url{https://www.cnblogs.com/justPassBy/p/5369930.html}}和
不可不戒\footnote{二分图:最大独立集\&最大匹配\&最小顶点覆盖
	\url{https://blog.csdn.net/lezg\_bkbj/article/details/9872189}}
的博客。
