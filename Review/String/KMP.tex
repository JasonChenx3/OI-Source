\section{KMP算法}
\index{K!Knuth–Morris–Pratt Algorithm}
\subsection{常规KMP}
KMP算法通过预处理nxt数组来避免重复匹配，$nxt[i]$指长度为$i$的模式串前缀
在模式串的前缀中的最长后缀长度（除自身外）。
\subsubsection{预处理}
可以利用之前的预处理信息跳nxt来找到最长后缀。
\begin{lstlisting}
int nxt[size];
void cook(const char* P) {
    int p=0;
    nxt[1]=0;
    for(int i=1;P[i];++i) {
        while(p && P[p]!=P[i])
            p=nxt[p];
        if(P[p]==P[i])
            ++p;
        nxt[i+1]=p;
    }
}
\end{lstlisting}
\subsubsection{匹配}
匹配和预处理的过程十分相似。
\begin{lstlisting}
void match(const char* str,int len) {
    int p=0;
    for(int i=0;str[i];++i) {
        while(p && P[p]!=str[i])
            p=nxt[p];
        if(P[p]==str[i])
            ++p;
        if(p==len)
            //match str[i-len+1...i]
    }
}
\end{lstlisting}
\subsection{ExKMP}
ExKMP用来计算主串的每个后缀与模式串的最长公共前缀。

留坑待补。

参见Star\_Feel的博客\footnote{算法导论————EXKMP
    \url{https://www.cnblogs.com/Never-mind/p/7776543.html}
}。
