\section{后缀自动机}
\index{S!Suffix Automaton}
\subsection{描述}
后缀自动机可用来识别母串的后缀，在转移的过程中可以识别母串的子串。
SAM使用最简状态表示。SAM是一个DAG，任何从初始状态出发的路径对应一个子串。

定义$ST(str)$为接受$str$后转移到的状态，$Right(s)$为能够转移到
该状态的子串的end位置集合（即字符串末端的下一位，且编号从0开始）。
给定状态$Right$集合的元素$r$，再确定子串长度$len$，就可以识别子串$[r-len,r)$。
发现若$l\in Right(s),r\in Right(s),l<r$，有$m\in Right(s),l\leq m \leq r$。
所以一个状态$s$映射了一段长度区间内的，末尾出现位置集合相同所有子串。
设其长度区间为$[l_s,r_s]$。

\subsubsection{状态Right集合之间的关系}
\begin{property}\label{SRP}
若状态$a,b$的$Right$集合有交集，则必满足一个集合是另一个集合的真子集。
\end{property}

若$Right(s)\subsetneq Right(fa)$，将$fa\rightarrow s$连边，构成了一棵Parent树。
可以发现$r_{fa}=l_s-1$，因此存储状态时只需存储$r_s$。
\subsection{构造}
与回文自动机类似，按顺序调用$extend$函数插入字符，时空复杂度$O(n)$。

对于每一个状态，维护其转移函数$nxt$，区间右端$len$，Parent树上父亲$link$。
SAM内维护一个末状态$last$，初始状态为1，表示空串。

插入步骤记为$SAM(T)\rightarrow SAM(Tx)$，即增加了Tx的后缀。
其中已加入的串为$T$，记$len(T)=L$。
步骤如下：
\begin{enumerate}
    \item 新建状态$s$，设$s.len=last.len+1$。
    \item 接下来考虑$s$能被哪些状态转移。所有表示$T$后缀的状态$c$，都满足位置
    $L+1 \in Right(c)$。显然$last=ST(T)$满足该条件，因为$Right(last)=\{L+1\}$。
    由性质~\ref{SRP}知在Parent树上$last$到根的链上状态的Right集合都有元素$L+1$。
    对于先前不能转移字符$x$的状态$c$，将其转移$x$设为$s$。
    显然从$last$到根连续有一段状态先前不能转移，因此设置转移直至遇到已有转移的状态才
    退出迭代，开始处理不能直接设置转移的情况。
    \item \begin{itemize}
        \item 若不存在已有转移的状态，令$s.link=1$后退出。
        \item 设已有转移的状态$p$的转移状态为$q$，若$p.len+1=q.len$，则
        $Right(s)\subsetneq Right(q)$，因此令$s.link=q$。
        否则克隆状态$q$为$cq$，其中$cq.len=p.len+1$，在Parent树上把链上状态转移
        $q$换为$cq$，同时令$s.link=q.link=cq$。
    \end{itemize}
    \item 更新$last=s$。
\end{enumerate}
\index{*TODO!重新描述SAM性质与构建}
注意SAM的点数不超过2n-2，边数不超过3n-3（转移边+Parent树边）。

代码如下：
\begin{lstlisting}
struct SAM {
    struct State {
        int nxt[26],link,len;
    } S[size*2];
    int last,siz;
    SAM():last(1),siz(1) {}
    void extend(int c) {
        int id=++siz;
        S[id].len=S[last].len+1;
        int p=last;
        while(p && !S[p].nxt[c]) {
            S[p].nxt[c]=id;
            p=S[p].link;
        }
        if(p) {
            int q=S[p].nxt[c];
            if(S[p].len+1==S[q].len)
                S[id].link=q;
            else {
                int cq=++siz;
                S[cq]=S[q];
                S[cq].len=S[p].len+1;
                while(p && S[p].nxt[c]==q) {
                    S[p].nxt[c]=cq;
                    p=S[p].link;
                }
                S[q].link=S[id].link=cq;
            }
        }
        else S[id].link=1;
        last=id;
    }
}
\end{lstlisting}
\subsection{Parent树}
注意Parent树上的父亲是儿子的后缀，因此匹配子串时可以
在转移边上跑，不行就跳Parent树的link（等同于fail树）。
\subsection{Parent树与后缀树的联系}
Parent树是反串的后缀树。
\subsection{计数问题}
对于每一个状态维护一个$right$值表示当前状态的Right集合大小。
新增状态时该状态贡献了1，但注意克隆状态并没有贡献，所以克隆后令$cq.right=0$。
最后拓扑排序dp就可以得到真实right值。

状态$s$表示了$s.len-s.link.len$个本质不同的子串，每种子串有$s.right$个。

优化：拓扑排序时可以按照len进行分层基数排序。
\subsection{线性构造后缀数组}
首先构造出SAM，发现last到根的链上的状态分别代表每一个后缀。对这些状态进行
标记，按照字典序DFS，维护DFS子串的长度$d$，通过遍历顺序得到$sa$数组。

注意对于跑单条链的情况要使用路径压缩优化。

代码如下：
\lstinputlisting{Source/Templates/SAM2SA.cpp}
\subsection{广义SAM}
有两种构造方法：
\begin{itemize}
    \item 在线：插入一个字符串之前将$last$重置，时间复杂度为O(Trie大小*字符集大小
    +叶子状态深度和)。
    \item 离线：先建出Trie，BFS插入，插入时把父亲在SAM上的编号当做$last$，
    时间复杂度为O(Trie大小*字符集大小)。
\end{itemize}

以上内容参考了WC2012陈立杰的讲课课件《后缀自动机 Suffix Automaton》
与Candy?\footnote{[后缀自动机]【学习笔记】
    \url{https://www.cnblogs.com/candy99/p/6374177.html}
}和dwjshift\footnote{
    用SAM建广义后缀树 $\ll$ dwjshift's Blog
    \url{http://dwjshift.logdown.com/posts/304570}
}的博客。Menci的博客写得更详细，一些性质的证明请移步
\url{https://oi.men.ci/suffix-automaton-notes/}。

\subsection{序列自动机}
类比后缀自动机，序列自动机上的每条路径对应一个子序列。

\subsubsection{构造}
序列自动机的构造比较简单，即预处理$nxt[i][j]$表示位置$i$后的第一个字符$j$
出现的位置。存在一个简单的$O(n|\alpha|)$DP：
\begin{lstlisting}
for(int i=n;i>=1;--i) {
    for(int j=0;j<26;++j)
        nxt[i-1][j]=nxt[i][j];
    nxt[i-1][P[i]-'a']=i;
}
\end{lstlisting}

维护可持久化数组可以把时间复杂度降到$O(n\lg |\alpha|)$，在字符集比较大的时候
使用。
\subsubsection{应用}
下列序列数统计均指本质不同的序列。
\paragraph{子序列个数}
记$dp[i]$为从位置$i$开始的子序列个数，位置$i$的字符自成一个子序列，
并且它与$nxt[i][j]$位置的方案构成了本质不同的子序列，因此有
\begin{displaymath}
    dp[i]=1+\sum_j{dp[nxt[i][j]]}
\end{displaymath}
使用记忆化搜索或者逆序dp。
\paragraph{公共子序列个数}
例题 「FJOI2016」所有公共子序列问题

预处理出两个字符串的序列自动机后，使用记忆化搜索在序列自动机上跑。
\paragraph{回文子序列个数}
对原串和反串构建序列自动机，求这两个串的公共子序列数。
记记忆化搜索调用为$DFS(x,y)$，$x,y$分别为在这两个串上的匹配位置，有
$x\leq n+1-y$，等号成立意味着该回文序列为奇序列。但是奇序列不一定满足
其等号成立，如果记忆化搜索搜索到一个偶回文序列，删掉该回文序列中心的一个字符，
就会出现新的奇回文序列，因此在搜索时若满足$x+y<n+1$，要补上该奇序列的贡献。
\paragraph{求满足存在指定子序列要求的最长公共子序列}
给定串$A,B,C$，求$A,B$的最长公共子序列$S$，要求$C$是$S$的子序列。
再给$DFS$增加一个状态记录其在$C$上匹配的位置后记忆化搜索。

上述内容参考了pig\_dog\_baby的博客\footnote{
    序列自动机（一个数组而已...）及经典例题
    \url{https://blog.csdn.net/pig\_dog\_baby/article/details/81145857}
}。
