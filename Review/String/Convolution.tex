\section{卷积法解决字符串匹配问题}
\subsection{回文子序列}
以某个位置为对称轴的回文子序列的个数可以由关于这个位置对称的字符对数计算。
每一对都有选与不选两种选择，除去全不选的情况，记对称字符对数为$k$，方案为$2^k-1$。

接下来考虑如何计算出对称字符对数。若字符串按照Manacher算法处理，对于每个对称中心$i$，
以它为对称中心的字符对满足$S[i-x]=S[i+x]$，注意到$i-x+i+x=2i$为定值，可以联系到卷积。
枚举字符集的字符，将有该字符的位置标为1，其余标为0，做一遍自卷积，位置$2i$的系数指示了以
$i$为对称中心的当前字符对数。由于同一个位置上会被统计1次，不同位置的对会被统计2次，所以
（系数+1）/2才是实际对数。时间复杂度$O(|\Sigma|n\lg n)$。

事实上卷积时不一定用Manacher算法预处理，将偶回文序列的对称轴看做$x.5$，其两倍仍然是
整数，可直接统计$[1,2n]$全部系数。

\subsubsection{例题} BZOJ3160: 万径人踪灭

本题要求的是回文子序列数，去掉是连续一段的回文子串。回文子序列数可以使用FFT卷积或者
序列自动机实现，回文子串数可以用Manacher或者PAM实现。

参考代码（NTT+Manacher）：
\lstinputlisting{Source/Source/'FFT NTT'/BZOJ3160.cpp}

由于卷积出的值很小（在$n$的范围内），FFT、NTT均可，注意控制FFT的精度（做完除法操作后
使用固定eps，如果想要省去除法操作，需要将eps乘以FFT规模作为实际eps）。
\subsection{带通配符匹配}
给定母串$S$与带通配符的模板串$P$，求$P$在$S$中的出现位置。

首先考虑不带通配符匹配的问题，可以使用KMP解决（带通配符则无法保持nxt的性质），但也有卷积
的方法。考虑如何将其表示为卷积的形式。如果母串$S$在位置$i$处匹配了$P$，那么有
$S[i+k-1]=P[k],1\leq k \leq|P|$。等式两边的下标之和不为定值，但它们的差为定值。那么
可以将$P$取反为$P_{rev}$，有$S[i+k-1]=P_{rev}[|P|-k+1],1\leq k \leq |P|$，两边
下标之和为$i+|P|$，可以进行卷积。同样考虑枚举字符集的字符，将有该字符的位置置为1，其余置0。
将每次卷积的结果累加，若位置$i+|P|$上的系数为$|P|$，则说明母串$S$在位置$i$匹配上了$P$。

有通配符的情况类似，每个有通配符的位置强制置1。

这种方法的时间复杂度仍为$O(|\Sigma|n\lg n)$。
\subsection{大字符集处理}
对于$|\Sigma|$较大的情况（比如26个字母），26次DFT的时间无法被接受。考虑如何把它们
放在一个式子内计算。考虑不带通配符的情况，将字母表示为数字，对应位相等则数字差为0。用
区间内差的绝对值之和为0表示整段对应区间数字差为0比较麻烦，索性使用平方和。那么有
$V[x]=\displaystyle \sum_{i=1}^{|P|}{(S[x+i-1]-P[i])^2}=0$，将平方展开，$P$
取反得到
\begin{displaymath}
    V[x]=\displaystyle \sum_{i=1}^{|P|}{S[x+i-1]^2+P_{rev}[|P|-i+1]^2-2S[x+i-1]P_{rev}[|P|-i+1]}
\end{displaymath}
仅需做一次卷积。考虑带通配符的情况，通配符无法表示为与26个数字都相等的数字，但是可以令其为0，
作为平方和的系数，也可以使整个式子的值为0。将式子拆开后可表示为两个卷积+一个常数的形式。
如果母串也带通配符，则再乘一个系数，表示为三个卷积之和。

参考代码：
\lstinputlisting{Source/Source/'FFT NTT'/BZOJ4503.cpp}

{\bfseries 使用FFT时，若最后不做除法，eps要开大些，比如0.5*p。
可以在做点值乘法时直接求和，仅需一次IDFT。}

上述内容参考了小蒟蒻yyb的博客\footnote{
    [复习]多项式和生成函数相关内容
    \url{https://www.cnblogs.com/cjyyb/p/10132855.html}
}。

\subsection{广义模式匹配}
例题：「THUPC2018」赛艇 / Citing

给定母方阵与模式方阵，求出所有匹配位置。

将母方阵按行拼接为一个串。模式方阵也如此拼接，但是行长要对齐到母方阵的行长便于匹配，
不在模式方阵的部分填为通配符。如此将该问题转化为带通配符的字符串匹配问题。

注意有可能出现一些匹配位置导致模式方阵在母方阵上面展开后错位的情况，因为实际上这个
匹配位置会导致模式方阵放上去后越界。为了避免这种情况，需要根据模式方阵的大小确定这个
匹配位置是否合法。
