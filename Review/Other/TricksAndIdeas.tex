\section{思路与技巧}
\subsection{二分/三分}
若目标函数具有单调性，或者题目要求``最大值最小/最小值最大''，一般
考虑二分答案然后检查其合法性。

若目标函数为凸（尤其是一些计算几何题），一般使用三分法判断函数的``轮廓''，
以达到缩小搜索范围的目的。使用斐波那契法（或者0.618法）在区间$[0,1]$选取点
$\frac{f_{n-2}}{f_n},\frac{f_{n-1}}{f_n}$或许会更玄学一些。
\subsection{补集转化}
根据``正难则反''的哲学，若正向思考不好解决，则考虑它的反面。尤其在
计数问题中考虑所求计数集合的补集。此外在并查集中引入补集的概念也是
个不错的方法。
\subsection{莫队}
对于离线的(修改+)查询问题，可以使用莫队算法来维护一些看似难以维护的信息
（比如区间颜色数）。

其思想是在能够快速对当前区间的左右端点进行移动并维护相应信息的情况下，
尽可能减少区间的移动距离。计算最优移动路径可表示为二维（三维）曼哈顿距离
最短哈密尔顿路径问题。一般使用简单的分块思想来达到较好的复杂度。

\subsubsection{例子}
若能$O(1)$对区间进行移动，且区间大小与查询/修改量同阶（设为$n$），则对查询
所涉及到的所有区间，对每个位置每$\sqrt{n}$分块编号，然后对查询以左端点所在块
编号为第一关键字，右端点位置为第二关键字排序（若需要支持修改操作，则第二关键字为右端点块
所在编号，第三关键字为时间）。处理询问时先移动到指定区间（若需要修改则移动到指定时间），
然后统计该询问的答案。

对于仅询问的问题，该方法的复杂度为$O(n\sqrt(n))$。因为对于$\sqrt{n}$个块，
每块内右端点最多移动$n$，而对于跨块转移，右端点最多移动$n$。由于查询/修改量与
区间大小同阶，左端点的移动也是$O(n\sqrt{n})$的。
\subsubsection{分块大小}
一般思路是推出各部分的复杂度，然后使用均值不等式调到最优复杂度。带修改时
注意查询移动与修改移动复杂度的平衡。
\paragraph{区间大小与查询量不同阶}
设区间大小为$n$，询问规模为$m$，块大小为$k$。右端点块内转移与跨块转移数
为$O(\frac{n}{k}\cdot n)$，左端点转移数为$O(mk)$，利用均值不等式可得
当$k=\frac{n}{\sqrt{m}}$时取得最优复杂度$O(n\sqrt{m})$。
\paragraph{修改+查询}
\begin{itemize}
	\item 左端点移动次数$O(nk)$；
	\item 右端点移动次数$O(nk)$；
	\item 修改移动次数$O(\left(\frac{n}{k}\right)^2\cdot n)$；
\end{itemize}
总复杂度为$O(nk+\left(\frac{n}{k}\right)^2\cdot n)$，对其求导并
令其导数为0，可得$k=n^\frac{2}{3}$，时间复杂度为$n^\frac{5}{3}$。
\subsubsection{树上莫队}
维护树的链上信息。

一种思路将树映射为括号序(不分+-)，然后按照处理普通序列的方法来做。
考虑点$x,y$所映射的区间（设$L[x]<L[y]$），若$x$是$y$的祖先（使用LCA判定），
则为$[L[x]，L[y]]$，否则为$[R[x],L[y]]$。为了抵消掉途经子树的贡献，对
每个点维护一个$vis$，根据$vis$判断当前点是否在贡献中，然后相应地加上或减去贡献。
注意查询答案时对于LCA处要特判，若$x$不是$y$的祖先，则要临时加入LCA，查询完毕后
删去，因为此时LCA的左右括号均不在区间内，而从x到LCA的链全为右括号，从LCA到y的链
全为左括号。

另一种思路是对树进行分块。分块算法参考第~\ref{dividing}节。

例题：WC2013 糖果公园
\footnote{https://www.luogu.org/problemnew/show/P4074}

代码如下：
\lstinputlisting{Source/Templates/TMD.cpp}
\subsubsection{奇偶排序卡常}
常规的查询区间排序是这样的：
\begin{lstlisting}
    bool operator<(const Query& rhs) const {
        return bid[l]!=bid[rhs.l]?l<rhs.l:r<rhs.r;
    }
\end{lstlisting}
这里有一个更好的排序方法：
\begin{lstlisting}
    bool operator<(const Query& rhs) const {
        return bid[l]!=bid[rhs.l]?l<rhs.l:
            ((bid[l]&1)^(r<rhs.r));
    }
\end{lstlisting}
也就是使两个相邻块内的询问右端点移动方向不同。将``[左->右]->[左->右]''改为
``[左->右]->[右->左]''减少了跨块转移的步数，效率提升明显。

该方法参考了洛谷日报第48期codesonic的文章\footnote{
	莫队算法初探 - \#include<codesonic>\\
	\url{https://www.luogu.org/blog/codesonic/Mosalgorithm}
}与RabbitHu的博客\footnote{
    胡小兔的良心莫队教程：莫队、带修改莫队、树上莫队 - 胡小兔
    \url{https://www.cnblogs.com/RabbitHu/p/MoDuiTutorial.html}
}。
\subsection{分块}\label{dividing}
\subsubsection{王室联邦分块法}
\subsubsection{DFS序分块法}
\subsubsection{size分块法}
