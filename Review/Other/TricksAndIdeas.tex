\section{思路与技巧}
\subsection{二分/三分}
若目标函数具有单调性，或者题目要求``最大值最小/最小值最大''，一般
考虑二分答案然后检查其合法性。

若目标函数为凸（尤其是一些计算几何题），一般使用三分法判断函数的``轮廓''，
以达到缩小搜索范围的目的。使用斐波那契法（或者0.618法）在区间$[0,1]$选取点
$\frac{f_{n-2}}{f_n},\frac{f_{n-1}}{f_n}$作为比较点或许会更玄学。
\subsection{补集转化}
根据``正难则反''的哲学，若正向思考不好解决，则考虑它的反面。尤其在
计数问题中考虑所求计数集合的补集。此外在并查集中引入补集的概念也是
个不错的思考方向。
\subsection{莫队}
对于离线的(修改+)查询问题，可以使用莫队算法来维护一些难以合并维护的信息
（比如区间颜色数）。

其思想是在能够快速对当前区间的左右端点进行移动并维护相应信息的情况下，
尽可能减少端点的移动距离。最优移动路径的计算可表示为二维（三维）曼哈顿距离
最短哈密尔顿路径问题。一般使用简单的分块思想来达到较好的复杂度\sout{（O(能过)）}。

\subsubsection{例子}
若能$O(1)$对端点进行移动，且区间大小与查询/修改量同阶（设为$n$），则对查询
所涉及到的所有区间，对每个位置每$\sqrt{n}$分块编号，然后对查询以左端点所在块
编号为第一关键字，右端点位置为第二关键字排序（若需要支持修改操作，则第二关键字为右端点块
所在编号，第三关键字为时间）。处理询问时先移动到指定区间（若需要修改则移动到指定时间），
然后统计该询问的答案。

对于仅询问的问题，该方法的复杂度为$O(n\sqrt{n})$。当左端点在$\sqrt{n}$个块时，
每块右端点最多移动$n$；而当左端点跨块转移时，右端点最多移动$n$，所以右端点移动
$O(n\sqrt{n})$。由于查询量与区间大小同阶，且左端点单次最多移动$2\sqrt{n}$，
左端点的移动也是$O(n\sqrt{n})$的。
\subsubsection{分块大小}
一般思路是推出各部分的复杂度，然后使用均值不等式调到最优复杂度。带修改时
注意查询移动与修改移动复杂度的平衡。
\paragraph{区间大小与查询量不同阶}
设区间大小为$n$，询问规模为$m$，块大小为$k$。右端点块内转移与跨块转移数
为$O(\frac{n}{k}\cdot n)$，左端点转移数为$O(mk)$，利用均值不等式可得
当$k=\frac{n}{\sqrt{m}}$时取得最优复杂度$O(n\sqrt{m})$。
\paragraph{修改+查询}
\begin{itemize}
	\item 左端点移动次数$O(nk)$；
	\item 右端点移动次数$O(nk)$；
	\item 修改移动次数$O(\left(\frac{n}{k}\right)^2\cdot n)$；
\end{itemize}
总复杂度为$O(nk+\left(\frac{n}{k}\right)^2\cdot n)$，令其导数为0，
可得$k=n^\frac{2}{3}$时最优，时间复杂度为$O(n^\frac{5}{3})$。
\subsubsection{树上莫队}
该方法用于维护树的链上信息，维护子树信息可以使用Dsu On Tree，参见第~\ref{DOT}节。

一种思路将树映射为括号序(不分+-)，然后按照处理普通序列的方法来做。
考虑点$x,y$所映射的区间（设$L[x]<L[y]$），若$x$是$y$的祖先（使用LCA判定），
则为$[L[x]，L[y]]$，否则为$[R[x],L[y]]$。为了抵消掉途经子树的贡献，维护一个$vis$
数组，根据$vis$判断当前途经点是否在贡献中，然后相应地加上或减去贡献，取反$vis$值。
{\bfseries 注意查询答案时对于LCA处要特判，若$x$不是$y$的祖先，则要临时加入LCA，
查询完毕后删去。因为此时LCA的左右括号均不在区间内，而从x到LCA的链全因右括号产生贡献，
从LCA到y的链全因左括号产生贡献。}

另一种思路是对树进行分块。分块算法参考第~\ref{dividing}节。分块后按照左右端点
所在块的编号排序，然后查询时在树上跑。

例题：WC2013 糖果公园
\footnote{https://www.luogu.org/problemnew/show/P4074}

代码如下：
\lstinputlisting{Source/Templates/TMD.cpp}
\subsubsection{奇偶排序优化}
常规的查询区间排序是这样的：
\begin{lstlisting}
    bool operator<(const Query& rhs) const {
        return bid[l]!=bid[rhs.l]?l<rhs.l:r<rhs.r;
    }
\end{lstlisting}

这里有一个更好的排序方法：
\begin{lstlisting}
    bool operator<(const Query& rhs) const {
        return bid[l]!=bid[rhs.l]?l<rhs.l:
            (bid[l]&1?r>rhs.r:r<rhs.r);
    }
\end{lstlisting}

也就是使两个相邻块内的询问右端点移动方向不同。将右端点移动路径由``[左->右]->[左->右]''
改为``[左->右]->[右->左]''，减少了跨块转移的步数。注意块编号从偶数开始。

该方法参考了洛谷日报第48期codesonic的文章\footnote{
	莫队算法初探 - \#include<codesonic>\\
	\url{https://www.luogu.org/blog/codesonic/Mosalgorithm}
}与RabbitHu的博客\footnote{
	胡小兔的良心莫队教程：莫队、带修改莫队、树上莫队 - 胡小兔
	\url{https://www.cnblogs.com/RabbitHu/p/MoDuiTutorial.html}
}。
\subsection{分块}\label{dividing}
\subsubsection{序列分块}
一般将序列分为多块，维护块内信息，区间查询/修改时整块处理，左右剩余元素暴力。
块的大小根据具体情况而定（整块/零散复杂度平衡，修改/查询复杂度平衡）。
\subsubsection{树分块}
\paragraph{王室联邦分块法}
DFS遍历儿子时子树节点数累积大于等于$B$，则将其当做一块。其余节点并入父亲所在块，
保证块的大小$\in [B,3B]$，且块的直径不超过$B$，但块不连通。
\index{*TODO!王室联邦分块法的块大小}

代码如下：
\lstinputlisting{Source/Templates/TreeDivide.cpp}
\paragraph{size分块法}
DFS时若父亲所在块还未到达指定size，将自身加入；否则新开一个块。
保证块的大小，连通性还有直径大小。

树分块相关内容参考了nimphy的博客\footnote{
	【初识】树上分块 - nimphy
	\url{https://www.cnblogs.com/hua-dong/p/8275227.html}
}。
\subsubsection{平衡修改与查询的复杂度}
例如对于规模为$n$的元素，修改复杂度为$O(n\lg n)$（比如暴力重建），而查询复杂度
为$O(\lg n)$。此时可以考虑每$\sqrt{n}$个元素分块，修改/查询复杂度均为
$O(\sqrt{n}\lg n)$。
\subsection{MITM}
\index{M!Meet In The Middle}
其主要思想是双向搜索（左+右/BSGS），然后使用hash表来查询满足题意
的集合。双向BFS搜索可以有效地减少状态数。

例题：Luogu P2324 [SCOI2005]骑士精神

暴力搜索的状态数为$3^{15}$数量级，但是双向BFS搜索的状态数为$2*3^8$数量级，
可以通过该题。每轮迭代中，两边各走一步，同时进行检测，这样做找到一组可行解就可以
返回了。

\lstinputlisting{Source/Source/Search/2324.cpp}
\subsection{倍增}
通过多一个$\lg$预处理跳跃$2^k$步的信息，以达到$\lg$级快速移动的目的。
\subsection{随机化}
对于一些时间复杂度为期望复杂度的算法，需要对数据顺序随机化来避免被卡。

对于枚举点对求最值的问题，在允许的运行时间内随机生成点对并计算也可以骗到不少分。
\subsection{按位拆分}
对于位运算相关问题，若位与位之间独立，则可以考虑按位拆分计算，这种做法可以
降低时间复杂度，简化代码。
\subsection{扫描线}
若某条件仅存在于一个区间/时间段中，则可在起点与终点的后一点处打添加/删除标记，
查询时先处理完当前时间的所有添加/删除的标记，再计算答案。
对于一些计算几何题也可以考虑使用该方法。
\subsection{差分}
\begin{itemize}
	\item 对于离线区间加法，可以在起点与终点后一点处打标记，最后做一遍前缀和。
	\item 对于序列相邻位置的不等式约束，有时也可以使用差分来转化问题。
	\item 对于具有单调性的序列，比如前缀/后缀最值，考虑差分后讨论修改位置。
\end{itemize}
\subsection{双指针法}
在区间最值问题中，若区间移动存在单调性（即对于每个左端点所对应的最优右端点是单调的），
则对于一个固定的左端点，使右端点移动到最优位置，然后将左端点移动一格，继续移动右端点。
此法的复杂度为$O(n)$。在两个区间上的组合问题也是如此（比如凸包矢量和问题）。
\subsection{优先队列维护长序列}\label{PQS}
若要取出超长/无穷序列的前k小值，且序列中较大的值的方案可以由较小的值的方案构造，
就可以预先加入原始的（不能被其它方案构造）方案到优先队列中，取出时加入其后继方案
到优先队列中。此法可保证优先队列的规模与算法时间复杂度在可接受的范围内。

有时甚至可以直接使用预排序+队列来代替优先队列（即$a\rightarrow a',b\rightarrow b',
a<b\Rightarrow a'<b'$时）。
\subsection{可删堆}\label{MultiSet}
一个简单的方法是使用$std::multiset$，但是其常数很大；
更保险的做法是使用两个优先队列（已加入/已删除）来完成操作：
\begin{itemize}
	\item 加入时将元素加入``已加入堆''；
	\item 删除时将元素加入``已删除堆''；
	\item 取堆顶时，若两堆堆顶相等则弹出，直到两堆堆顶不相等，返回``已加入堆''
	      的堆顶。
\end{itemize}
\subsection{二进制分组}\label{BinIns}
对于在线向序列右端插入元素的操作（不修改/删除），可以按照最大规模固定规模分块后建块，
询问时对每块暴力查询。假设重建块的复杂度为$O(n\lg n)$，查询复杂度为$O(\lg n)$，
询问量$q$与元素最大规模$n$同阶。离线问题则可以考虑对时间分治，当然不管哪种方法都要求
插入的贡献独立。

考虑将当前序列长度进行二进制拆分，然后令每个拆分值对应一个块的大小。
即新加入一个元素作为独立块后，不断检查块序列最右端两个块大小是否相等，相等则合并
为一块并重建（注意要先标记范围再合并（可以$O(1)$得到范围，见下文），每次插入最多合并一次）。
此法保证了查询时块的数目是$\lg n$的，比固定大小分块算法更优。

接下来证明插入复杂度：

插入第$k$个元素后，需要合并的元素数为$lowbit(k)$，设$n$为$2$的幂，有
\begin{eqnarray*}
    T(n)&=&\sum_{k=1}^n {lowbit(k)\cdot \lg lowbit(k)}\\
        &=&\sum_{k=1}^{\lg n} {\frac{n}{2^{k+1}}\cdot k\cdot 2^k}\\
        &\leq&\sum_{k=1}^{\lg n} {n \lg n}\\
        &=&O(n\lg^2 n)
\end{eqnarray*}
\subsection{整体二分}
对于某些离线问题，若其询问仅一种且可二分，整体二分是个不错的选择。
其思想是将所有询问的二分操作放在一起，分治将询问分组到两个区间中。
分治时可以顺便处理修改操作。

记整体二分主过程为$solve(beg,end,l,r)$，其中二分询问/查询为$[beg,end)$，
二分答案范围为$[l,r]$。

步骤如下：
\begin{enumerate}
	\item 若区间元素为空则返回；
	\item 若$l==r$，设置区间内元素的答案为$l$并退出；
	\item 令$m=(l+r)/2$；
	\item 施加$[l,m]$内的修改，累积到每个询问的贡献（注意要保证这部分的复杂度与
	区间长度相关）；
	\item 对于修改按照位置分为左右集合，对于询问按照当前累积贡献与目标值的关系
	将其分为2个集合；
	\item 递归分治左右集合。
\end{enumerate}
\subsection{cdq分治}\label{CDQ}
cdq分治用来解决偏序问题（支持动态偏序问题，但仍然要求离线）。

步骤如下($solve(l,r)$)：
\begin{enumerate}
	\item 若区间元素为空则返回；
	\item 令$m=(l+r)/2$；
	\item 递归分治处理左右集合；
	\item 计算一边集合对另一边集合的影响（比如左边元素对右边元素答案的影响，
	左边修改对右边查询的影响，有时左右元素会互相影响）。
\end{enumerate}

对于静态偏序问题，可以将第一维当做时间，转化为动态偏序问题。
对于动态偏序问题，保证第一维按照时间排序，递归合并时边计算影响边进行归并排序，
使其排序后位置从小到大，修改优先于查询（要保证两集合内部元素的时间先后关系，即排序要稳定）。
\subsection{Kernelization}
\index{*TODO!Kernelization}
参见\url{https://www.zhihu.com/question/272303098/answer/367368615}。
\subsection{注意事项/常见转化}
\begin{itemize}
	\item 边读入边处理时不要跳出循环，若要跳出循环则需继续读入以跳过冗余数据。
	\item 求解区间相交/包含/相离问题时首先判断这三种情况是否合法。若相交不合法，可以
	考虑将区间缩点。对于序列问题考虑其置换$b_{a_i}=i$。（WYX'S BLOG
	\footnote{[CTSC2018]青蕈领主\url{http://blog-wayne.com/2018/05/16/523/}}）
	\item 「雅礼集训 2017 Day8」价：最小割建图时考虑与inf加减作为边权。
	\item 「TJOI / HEOI2016」字符串：前缀$\rightarrow$后缀，使用后缀系列算法解决。
	\item 删除+可离线$\rightarrow$逆序加入
	\item [LNOI2014] LCA：两点的LCA深度可以理解为一个点到根的链标记+1，统计另一个点
	到根的标记总和。
	\item 「LibreOJ Round \#6」花火：将点的编号与点值视为二维平面上的一个点
	$P_i=(i,h_i)$，若交换$i,j$则减少了$P_i,P_j$矩形内的点数（不含边界）*2+1。
	可以推出$h_i$一定是前缀最大值，$h_j$一定是后缀最小值，否则存在更优的矩形。
	求出前缀最大点集$L$与后缀最小点集$R$后，设选择的矩形为$(i,j)$，考虑点$k$被包含
	在$(i,j)$内的条件。记$l$为前缀最大点集中在$k$左上方的点的最左位置，$r$为后缀最小点集
	中在$k$右下方的最右位置，这两个均可以二分处理。那么条件为$i\in [l,k-1],j\in [k+1,j]$，
	将问题转化为每个点$k$覆盖一个矩形，求点的最大覆盖值。使用扫描线+线段树解决。最后答案为
	逆序对-最大覆盖数*2（可非相邻交换1次与减少1对逆序对抵消）。
	\item 「LibreOJ Round \#11」Misaka Network 与任务：需要大量同指数快速幂且已知
	底数范围时使用线性筛预处理。
\end{itemize}
\subsection{本节注记}
2013年许昊然的国家集训队论文答辩《浅谈数据结构题的几个非经典解法——<Claymore>命题报告》
中提到了不少奇妙的解法。
