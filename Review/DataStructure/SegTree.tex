\section{线段树}
线段树用于支持快速区间加法的数据维护。
\subsection{技巧}
\subsubsection{全局最优值剪枝}
可以使用全局变量维护自己当前遍历到的最优值，若父节点维护的信息表明管辖范围内不可能
出现更优值，则直接返回减少递归深度。（在kd-tree中比较有效）
\subsubsection{局部最优值剪枝}
例如维护区间max值时，顺便维护区间min值，modify时发现操作无效直接退出。
\subsubsection{不使用子树信息合并更新}
比如单点加法，sum值可以直接在下降时维护，而不用从子树信息update。
\subsubsection{标记永久化}
直接将对整个区间的操作存到标记中而不下放，统计时加回去，减少空间占用（标记即值）与
标记下放常数，对可持久化友好。不过有些边界问题要小心处理。
\subsubsection{代替平衡树}
在一些简单的场合中，可以使用值域线段树/树状数组完成平衡树的功能。对于不满足值域
要求的，使用离散化预处理。常数比平衡树小得多。
\subsection{zkw线段树}
\index{Z!zkw's Segment Tree}
如果线段树维护的区间是$[0,2^N)$，区间$[b,e)$对应的子区间为$[b,m),[m,e)$，则
该线段树是一棵perfect binary tree。可以发现叶子节点的编号是对应原数组下标编号$+2^N$。
那么就可以非递归地找到叶子，然后让叶子同步向上跳。

实际实现时先将闭区间变为开区间，然后找到区间端点对应的叶子，统计内部的区间，再向上跳，
直到{\bfseries 两个节点是兄弟为止}。

\subsubsection{简单操作}
以区间求和为例：
\begin{lstlisting}
off=1<<N;
int res=0;
for(s+=off-1,t+=off+1;s^t^1;s>>=1,t>>=1) {
    if(~s&1) res+=A[s^1];
    if(t&1) res+=A[t^1];
}
\end{lstlisting}

单点修改直接从叶子节点开始向上跳。构造线段树时从$off-1$（最后一个非叶子节点）到$1$~update。

由于需要转化为开区间，实际支持的查询区间为$[1,2^N-1)$，最大空间仍旧为4倍原数组大小。
\subsubsection{带标记操作}
原先区间修改需要打标记，不得不回到自顶向下的递归方法。使用标记永久化，就可以支持
自底向上修改与查询。有些情况下标记与值的意义是相同的。对于区间加法，区间最值这类问题
可以使用差分思想将值转化为自身的值与父亲之差使其可以标记永久化。

上述内容参考了zkw的课件《统计的力量——线段树全接触》。
\subsection{势能分析线段树}
对于某些无法打标记的区间操作（例如区间元素开根号），若该操作对某个元素施加有限次操作就会使
区间元素不再变化，同样可以使用线段树。每次区间操作暴力修改，合并时维护下次操作对区间内元素
是否均无效。
\subsection{Segment Tree Beats（吉司机线段树）与历史最值问题}
\index{S!Segment Tree Beats}
该线段树用于解决有类似``将区间内小于$x$的数变为$x$''修改操作的问题。
\subsubsection{主要思想}

该线段树除了维护区间最小值外，还维护了区间的严格次小值。那么当$x\leq$最小值时，直接退出；
当最小值$<x<$次小值时（注意如果条件为$x\leq$次小值，虽然取等号时仍然可以维护序列，但是
此时次小值变为了最小值，无法维护新的次小值），根据其它信息维护整个区间；否则递归到子区间
中处理。在序列规模为$n$，操作数为$m$时，时间复杂度$O(m\lg^2 n)$，一般情况下该上界很松，
更接近$O(m\lg n)$。若没有其它种类的区间修改操作（比如区间加法），时间复杂度为$O(m\lg n)$。
\subsubsection{细节}
\paragraph{push操作}这类操作不使用懒标记更新儿子。考虑区间取max操作，如果在push时
发现子区间的最小值比整个区间最小值更小，就意味着整个区间执行过一次该操作，此时对该子区间
下放标记。

\paragraph{同时有取max与min操作}注意更新时区间内所有的值相同的情况，比如更新max时
可能会影响到min的值。push时不必考虑两个操作的下传顺序。

\paragraph{维护多数组}
每个位置在每个数组中有两个属性，即是/不是最值。对每种属性组合的位置分别维护，时空复杂度
多了$O(2^k)$因子，$k$为数组数。

\paragraph{例题 BZOJ4695 最假女选手}
按照套路维护区间最值，次最值，为了支持区间和的询问还要维护最值个数。update时尽量减少判断
以使代码简短，易于Debug。

参考代码：
\lstinputlisting{Source/Source/SegmentTree/BZOJ4695.cpp}

\subsubsection{区间最值问题转化为区间加减问题}
注意到在上述方法区间取min/max打标记时，只有区间最值受到影响。那么就可以将其转化为对节点管辖
范围内最值的加减操作。在标记下传时仅传到受影响的儿子中。
\subsubsection{历史最值问题}
历史最值问题即在维护一个序列的同时，支持询问指定位置从开始到当前时刻的最值/版本和，甚至指定区间
的历史最值的最值/和，历史版本和之和。

区间加减+历史最值：除了维护整体加减标记$add$外，还维护整体加减标记从上一次标记下传到现在的最值$pre$。
那么节点$u$到儿子$v$的标记下传为$pre_v=max(pre_v,add_v+pre_u),add_v+=add_u$。

+区间覆盖：额外维护覆盖标记也可以完成标记下传与更新。

+区间最值/加减带Clamp：此时使用一种通用的标记$(a,b)$，表示区间全体$+a$，再与$b$取最值。
那么区间加减表示为$(x,\pm\infty)$，区间覆盖表示为$(\pm\infty,x)$，区间最值表示为$(0,x)$，
区间加减带Clamp表示为$(x,0)$。以对$b$取max为例，标记下传时
$b_v=max(b_v,b_u+a_v),a_v+=a_u$。

+查询区间历史最值的最值：使用区间加减操作执行区间最值操作。

区间加减+区间历史最值之和：维护当前数组$A$，差值数组$C=A-B$，其中$B$为历史最值数组。那么区间加减可以
转化为对数组$C$的区间加减带Clamp操作。两数组的区间和之和即为答案。

区间加减+区间历史版本和之和：参见第~\pageref{HistorySum}页中`` 支持有后效性的可加减区间操作，
询问历史版本和''。

+区间最值：同样按照是否为最值分类讨论。

上述内容参考了santongding\footnote{
    吉司机线段树(segment tree beats!)\\
    \url{https://blog.csdn.net/qq\_36284842/article/details/80058746}
}与Galaxies\footnote{
    bzoj4695 最假女选手\\
    \url{https://www.cnblogs.com/galaxies/p/bzoj4695.html}
}的博客，以及C\_SUNSHINE和jiry\_2的营员交流课件《Segment ree Beats!》，还有
吉如一的2016年国家集训队论文《区间最值操作与历史最值问题》。

\index{*TODO!提高对Segment Tree Beats的理解}
\subsection{线段树分治}
对于可离线线段树套其它数据结构的树套树问题，有时会因为空间不够导致无法使用树套树，并且
树套树代码量大，不易调试。

既然这类问题可离线，可以考虑将所有询问同时在线段树上移动。对询问进行分治，每次处理分治区间
时，先建出查询数据结构，然后对完全包含这段区间的询问进行查询并更新答案，再清空数据结构，
将其它询问分治到左右子区间中求解。使用分治可以保证任意时刻只有单个区间的查询数据结构。

\subsubsection{例题 [FJOI2015]火星商店问题}
典型的线段树套可持久化Trie问题，使用线段树分治毫无空间压力，时间复杂度与原做法相同。

参考代码：
\lstinputlisting{Source/Source/SegmentTree/P4585.cpp}
\subsection{线段树优化建图}
对于一个点到一个或多个连续区间内的点有连边且区间内的边权相等，考虑使用线段树优化建图。
即使用线段树的上层节点代表管辖区间内的所有节点，建树时上层节点向左右儿子连权值为0的边
（{\bfseries 注意上层节点区分入点与出点，与儿子连有向边}），建图时类似modify操作连边，边数由
$O(mn)$降为$O(m\lg n)$。上层节点起到了``捆线带''的作用。

例题：CF786B Legacy

线段树优化建图+裸最短路。

\lstinputlisting{Source/Source/SegmentTree/CF786B.cpp}
\subsection{猫树}
当无修改，区间查询次数多，区间信息仅支持结合律与快速合并时（不可减，不可重叠），
猫树可以以更多预处理时间与空间的代价使单次查询复杂度变为$O(1)$。

这种情况下一般使用线段树解决，但是线段树查询时需要合并$O(\lg n)$次信息，考虑如何将合并
次数降到$O(1)$。以下不讨论$l=r$的平凡情况。由于区间端点$l,r$分别在线段树上对应了某个节点
的mid，可以考虑预处理所有节点的mid到管辖范围中每个点的信息（左右方向在$m$处一开一闭），
查询时快速找到某个mid满足$l,r$在它的管辖区间内且分别在它的两侧，利用预处理的$[l,mid)$与
$[mid,r]$的信息，$O(1)$合并回答询问。

接下来考虑如何寻找mid对应的线段树节点id。事实上这个节点就是$l,r$对应节点的LCA。
{\bfseries 猫树使用的是zkw线段树的节点标号方式，}$l,r$的节点编号的LCP就是mid的
节点编号。使用位运算$id_l>>(1+\lg(id_l\oplus id_r))$可以实现$O(1)$求LCP。

参考代码（LOJ\#6057. 「HNOI2016」序列~数据加强版）：
\lstinputlisting{Source/Source/SegmentTree/LOJ6057.cpp}

\subsubsection{扩展}
虽然必须``无修改''，但是猫树结合二进制分组可以支持``向后插入''，可以用来优化DP。

对于树上链信息询问，如果使用DFS序+树链剖分会带来$O(\lg n)$的复杂度。考虑点分治，
预处理重心到子树内每个点的链信息。由于区间信息合并不可重叠，要分别预处理包括重心与不包括重心
的信息。查询链对应的重心时在点分树上查询LCA。为了得到$O(1)$的查询复杂度，需要$O(1)$LCA
与$O(1)$hashTable求节点到重心的信息对应位置。

参考代码（LOJ\#2013. 「SCOI2016」幸运数字）：

这题使用点分治+猫树有点杀鸡用牛刀的感觉。因为本题可离线。

\lstinputlisting{Source/Source/'Point-Based Partition'/LOJ2013.cpp}

上述内容参考了immortalCO的博客\footnote{
    一种高效处理无修改区间或树上询问的数据结构（附代码）
    \url{http://immortalco.blog.uoj.ac/blog/2102}
}。
\subsection{线段树合并}
该方法适用于总插入数（叶子数）为定值，且父线段树可以由子线段树的信息合并的情况。合并两棵子树时，
若两棵子树都非空，则信息相加并返回某个节点（若需要可持久化则新开节点），否则返回有效的节点编号。

记值域为$n$，总共有$m$棵含单个元素的线段树合并。该方法的时间复杂度为$O(m\lg n)$，理由是该方法的复杂度
不会比将元素逐个插入一棵空线段树更差。

该方法参考了黄嘉泰的课件《线段树的合并——不为人知的实用技巧》。
