\section{Hash表}\label{HashTable}
由于std::unordered\_set并不能满足实际性能需要，在此谈谈用于OI的Hash表设计。

事实上std::unordered\_set性能低下也是情有可原的，因为它需要面对的应用场合繁多。
但在OI应用中，我们能够预知全集的大小，元素一般为整数，且只需要支持插入、查询和清空操作，
而通用的std::unordered\_set并不知道这些信息。

下列方法的性能以LuoguP3727~曼哈顿计划E的评测结果为准（不幸的是\\std::unordered\_set
光荣地TLE了）。

\subsection{链接法}
链接法使用std::vector<int>当链表，以整数低位为关键字，查询时使用std::find暴力搜索，
插入时直接push\_back，清空时将已插入值对应的桶清空。

测试结果：943ms。
\subsubsection{散列函数设计}
一个好的散列函数应该考虑Key的所有位，而简单地以低位为关键字是个糟糕的选择。模$2^p$和
$2^p-1$都不太好。应该选取不太接近2的幂的素数。

将模数从$2^{20}$改为$65537$后测试结果为364ms，优化效果显著。
\subsection{双重散列+开放寻址法}
开放寻址法存放一个较大的表，插入时取得Key的散列值$h(Key,0)$，然后查看该处是否有不同
元素，若有则移动到位置$h(Key,1)$，以此类推，直至找到一个空位或发现已插入为止。查询也是如此。

散列函数使用双重散列法，即$h(k,i)=(h_1(k)+ih_2(k))\bmod m$。表的大小$m$一般
取素数，$h_1(k)=k\bmod m,h_2(k)=c+k \bmod m',m'<m$。一般取两个插入规模2倍以上的相邻素数
且$c=1$。装载因子$\alpha$的散列表的平均期望探查数为$\frac{1}{\alpha}\ln \frac{1}{1-\alpha}$。

测试结果：317ms。

\CJKsout{2019.3.2：为什么又是rank2。。。}

{\bfseries 使用这种方法时一定要保证关键字非负，尤其是对字符串使用自然溢出Hash时。}
\subsection{完全散列}
完全散列适用于静态关键字集合的查询。适用于BSGS等场合。

留坑待补。
\index{*TODO!完全散列}

上述内容参考了算法导论\cite{ITA3}第11章~散列表。
