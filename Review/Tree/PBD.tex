\section{点分治}
点分治就是每次选择树的重心（儿子的子树大小的最大值最小的节点）作为分治点，
以分治点为根将整棵树分为多棵子树，统计当前节点的答案，
然后递归每棵子树分治。这种方法一般用来解决{\bfseries 路径统计问题}。
\subsection{常规点分治}
\subsubsection{重心性质}
\begin{property}\label{WPP}
    重心的儿子子树大小不超过整棵树大小的一半。
\end{property}
证明：考虑重心为$R$，设$R$的某个儿子$u$满足其子树大小超过
$\frac{N}{2}$，那么点$u$比点$R$更优，与重心为$R$的条件矛盾。
\begin{property}
    所有点到重心的距离和最小，到两个重心的距离和相等。
\end{property}
\begin{property}
    两棵树合并后的重心在这两棵树的重心的路径上。
\end{property}
\begin{property}
    添加或减少一个叶子节点，重心最多偏移一条边。
\end{property}

\paragraph{树的同构判定}
对于一棵有根树可以使用一些Hash规则计算子树的Hash值（合并子树Hash值的运算需要满足交换律或
排序后合并，我的做法是计算多个满足交换律的运算合并值，然后把这些值胡乱混合）。以无根树
的重心（1-2个）为根，就可以计算整棵树的Hash值，用于树的同构判定。

{\bfseries 血泪史：存储当前最优点的数组大小要开$n$而不是2。尽管重心不超过2个，
但在处理过程中仍然存在超过2个的现行最远点。我在下面的板子中由于kp数组开小了而导致
last数组被覆写产生环，因此我调了一晚上。。。望引以为戒。}

\lstinputlisting{Source/Templates/TreeHash.cpp}

\subsubsection{重心选择}
以当前连通块内任意一点为根（当然是上一个分治点的儿子）DFS，计算每个节点儿子的子树大小的
最大值，然后与除自己子树外的节点数求最大值（儿子为有根树意义下的父亲时的子树），就得到
当前节点的权重。

使用$vis$数组来标记节点是否已成为分治点，阻止其跨出连通块。

\begin{lstlisting}[title=getRoot]
bool vis[size];
int root,tsiz,msiz,siz[size];
void getRootImpl(int u,int p) {
    int maxs=0;
    siz[u]=1;
    for(int i=last[u];i;i=E[i].nxt) {
        int v=E[i].to;
        if(!vis[v] && v!=p) {
            getRootImpl(v,u);
            siz[u]+=siz[v];
            maxs=std::max(maxs,siz[v]);
        }
    }
    maxs=std::max(maxs,tsiz-siz[u]);
    if(maxs<msiz) {
        msiz=maxs;
        root=u;
    }
}
int getRoot(int u,int csiz) {
    msiz=1<<30;
    tsiz=csiz;
    getRootImpl(u,0);
    return root;
}
\end{lstlisting}

\subsubsection{分治与统计}
每次把重心作为分治点，DFS统计从分治点出发的贡献，将分治点到子树各点的路径信息平铺成序列，
用$O(n)$（单调队列、双指针）或$O(\lg n)$（线段树）算法两两合并，再对于每棵子树去除来自
同一棵子树的贡献（因为这些路径经过了两次从分治点到子树的边，不是简单路径）。

当然也可以使用树形dp惯用的技巧：在统计从分治点出发的贡献时将儿子子树分开处理，每棵子树
DFS一遍查询与已处理子树节点（或者与分治点本身）的贡献，再DFS一遍维护数据结构（线段树常数
好大）便于下一次查询。如此就不会统计来自相同子树的贡献了，注意数据结构的清零要控制为$O(1)$。
{\bfseries 关键：利用时间来存储数据。}

\begin{lstlisting}[title=divide]
void divide(int u) {
    //count u->child
    vis[u]=true;
    for(int i=last[u];i;i=E[i].nxt) {
        int v=E[i].to;
        if(!vis[v]) {
            //minus v->u->v
            divide(getRoot(v,siz[v]));
        }
    }
}
\end{lstlisting}

\subsubsection{时间复杂度}
点分治会带来$O(\lg n)$的复杂度，证明：

根据性质~\ref{WPP}，点分治的层数为$O(\lg n)$，而且每层的总规模都是$n$。

\subsection{动态点分治}
动态点分治就是在分治时连接当前分治点与子连通块的分治点，
这些点构成了一棵点分树，多次查询时使用点分树来计算。

注意一般节点$u$需要维护{\bfseries 自己的子树节点到自己在点分树上父亲的信息}，记为A。
那么节点$u$子树节点经过自身的路径信息就由儿子的信息A决定。修改信息时自底向上更新祖先的信息。

\subsubsection{例题}

Luogu P4115 Qtree4\footnote{【P4115】Qtree4 - 洛谷
\url{https://www.luogu.org/problemnew/show/P4115}}

首先点分治建出点分树。
对于每个节点维护两个可修改堆，堆A维护子树白节点到该节点父亲的距离，堆B维护
该节点儿子们的堆A最大值，那么经过该节点的最长路径为堆B的最大值+堆B的次大值。
注意自身就是白点的情况。再用一个全局可修改堆维护经过每个节点的最长路径。

实践中双$std::priority\_queue$维护可修改堆比$std::multiset$跑得更快，
参见第~\ref{MultiSet}节。

代码如下：
\lstinputlisting[title=Luogu P4115]
{Source/Source/'Point-Based Partition'/4115queue.cpp}
