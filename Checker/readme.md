# Checker ~~懒到一定境界的产物~~
-------------------
这是一个功能强大的本地评测器。

为什么这些事我不一次性搞定呢？当然是需求推进科技进步啦！~~都说了我懒~~

## Feature

- 评测（~~废话~~）并返回时间、内存使用信息
- 统计system call以及性能分析信息，浮点比较时统计精度
- 自动扫描并匹配数据以及待评测程序（最新编译的可执行程序）
- 支持从LOJ上获取时限、内存限制和数据

## Change Log
### 2018

#### fc.cpp时代

1.0.0(7.11(init)) 用眼比对太麻烦了，索性写个类似fc的东西

1.1.0(11.7)
LOJ上可以下载数据，懒得手动逐个比对，干脆按照编号自动扫描，同时还能算成绩

#### checker.cpp时代

1.1.0(11.16) fc.cpp->checker.cpp

1.1.1(11.21) RE也能AC？得特判system返回值

1.1.2(11.30) 读入long long会爆int，干脆用long long吧

1.1.3(12.4)
YES/NO怎么判？干脆像diff那样匹配文本，改读std::string

1.1.4(12.10)
有些LOJ题目的测试点编号前居然有前缀！！！懒得逐个改前缀，直接在控制台输入前缀。
顺便防止输错前缀导致SIGFPE

1.1.5(12.30)
少输出也能AC？不行得把读入头移回去反过来再匹配一遍（后来证明我的algorithm姿势
还是不够）

### 2019

1.1.6(1.6)
还有".ans"后缀的答案文件，不想多次改刷change，索性暴力判断两个后缀是否可行

1.2.0(1.7) ~~我要当rank2！！！~~我需要测量运行总时间

1.2.1(1.16)
假设std::chrono:high_resolution_clock的单位是纳秒是不对的！！我要跨平台！！！
~~我就这一台电脑。~~

1.2.2(1.17) 似乎自己把判题的时间一起算进去了。。。

#### Checker自动化

2.0.0(3.23)
APIO的测试点命名把我搞得很惨，为什么有01开头？为什么有那么多的子任务？
为什么还用字母区分数据种类？为什么还用无后缀和.a表示输入输出？不行我要
自动扫描并匹配输入输出文件！！！为此引入了std::filesystem。

程序超时后面的测试点没法测怎么办？Ctrl+C一不小心就把checker给结束了。
我需要使用类似ulimit的东西来限制时间，同时开栈。似乎不能用system，那就
下决心使用fork+execv，发现wait4可以得到程序的资源使用信息，可以判断TLE
和MLE了！！！居然还有异常退出的情况？那就顺便判断RE（细分各种信号量）。

2.1.0(3.25)
通过控制测试程序的浮点输出精度来与标准答案在文本上一模一样做不下去了，
干脆再加个flag指示是否使用浮点比较。同时改了一下智障的双向判断。
~~没有好好研究<algorithm>的下场~~

2.2.0(3.26)
把WA的时间和内存记录进去，同时记录极限测试点的运行时间。（最正经的记录）

2.3.0(3.27)
集成perf用于研究CacheMiss等性能指标。给不断成长的Checker写点历史。
懒得输入待测试程序名了，直接使用bin文件夹下除checker,charCounter外的最新
的可执行程序作为测试程序。

2.3.1(3.28)
修正内存测量，以/proc下的VmPeak值为标准

2.4.0(3.29)
修复SIGTRAP信号导致Checker死循环，支持处理被STOP的程序，记录syscall
perf信息读入，全部AC后自动做perf给出性能指标

2.5.0(3.30)
浮点数比较模式记录最大精度误差，检查最大输入输出大小，开栈

#### Checker模块化

2.6.0(3.31)
分离各部分的实现，支持LOJ自动获取题目信息和数据

2.6.1(4.1)
缓存下载数据，校验数据包，过滤调用较少的system call并修改统计方式，
提高正则表达式效率，支持BZOJ离线题目与数据获取，根据样本对本机评测时间进行缩放

2.6.2(4.2)
修复因为题目名称太长导致Checker在输出分割线时卡死的问题~~捂脸~~

2.6.3(4.3)
AC后询问OJ上的时间并加入samples中，在BZOJ计时方式下skip掉剩余测试点

2.6.4(4.5)
发现BZOJ上的SPJ读入nan后可A，添加对特殊浮点数的特判；
优先调用SYZOJ的judge，缺省时使用默认problem.yml（由于太垃圾默认不支持）

2.7.0(4.6)
输出最大栈大小，支持预测OJ上的时间

2.7.1(4.8)
准备跨Windows平台，Timer全部使用用户态计时以避免计算syscall钩子的开销

2.8.0(4.9)
初步跨Windows平台，并且将评测有关文件移至临时文件夹

2.8.1(4.10)
解决Windows平台下控制台输出乱码问题，支持基本评测功能

2.8.2(4.11)
支持Windows下异常捕捉，使用Cmake支持自动更新

2.8.3(5.13)
修复CheckerDir不一致的bug，扩大Adapters识别范围，增加perf开关

2.8.4(5.14)
修复系统时间超时产生SIGXCPU信号，误判TLE的问题。

2.9.0(5.15)
支持UOJ题目读取与样例数据下载

## TODO List

- [x] 跨Windows平台、分离平台实现
- [ ] 支持LOJ的SPJ
- [x] 支持LOJ的data.yml
- [x] 自动下载并解压数据，自动获取时限和内存限制
- [ ] 全部AC时自动提交代码
- [x] 自动更新（使用CMake）
- [ ] 本地性能比较（从OJ上扒代码）
- [x] 序列化配置OJ
- [ ] 功能模块化
- [x] 评测机与本机时间缩放
- [ ] 支持文件输入输出
- [ ] 支持提交答案题
- [ ] 支持Hardware Counter Profiling[HCP](https://docs.microsoft.com/en-us/windows/desktop/api/_hcp/)
- [ ] 支持SubTask
- [ ] 挂起运行
